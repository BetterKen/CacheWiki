# 17 RedisCluster

## 17.1 redis cluster介绍

![](http://cache410.oss-cn-beijing.aliyuncs.com/rediscluster.png)



- 自动将数据进行分片,每个master上放一部分数据
- 提供内置的高可用支持,部分master不可用时,还是可以继续工作的，因为每个master都有salve节点，那么如果mater挂掉，redis cluster这套机制，就会自动将某个slave切换成master；
- 支持读写分离：对于每个master来说，都负责写请求，写就写到master，然后读就从mater对应的slave去读；

redisCluster是Redis的官方分布式解决方案,解决了上一章提到的Redis主从模式的1,2,3缺陷

redisCluster = 多master+读写分离+sentinal



## 17.2 分区规则 

### 17.2.1 常见分区规则

分布式数据库首要解决把整个数据集按照分区规则映射到多个节点的问题，即把数据集划分到多个节点上，每个节点负责整个数据的一个子集。

常见的分区规则有`哈希分区和顺序分区`。Redis Cluster采用哈希分区规则，因此接下来会讨论哈希分区规则。常见的哈希分区有以下几种：

- 节点取余分区
- 一致性哈希分区
- 虚拟槽分区

Redis Cluster采用虚拟槽分区



### 17.2.2 hash算法

来了一个 key，首先计算 hash 值，然后对节点数取模。然后打在不同的 master 节点上。一旦某一个 master 节点宕机，所有请求过来，都会基于最新的剩余 master 节点数去取模，尝试去取数据。这会**导致大部分的请求过来，全部无法拿到有效的缓存，导致大量的流量涌入数据库**

![](http://cache410.oss-cn-beijing.aliyuncs.com/hash-1.png)

### 17.2.3 一致性 hash 算法



一致性 hash 算法将整个 hash 值空间组织成一个虚拟的圆环，整个空间按顺时针方向组织，下一步将各个 master 节点（使用服务器的 ip 或主机名）进行 hash。这样就能确定每个节点在其哈希环上的位置。

来了一个 key，首先计算 hash 值，并确定此数据在环上的位置，从此位置沿环**顺时针“行走”**，遇到的第一个 master 节点就是 key 所在位置。

在一致性哈希算法中，如果**一个节点挂了，受影响的数据仅仅是此节点到环空间前一个节点（沿着逆时针方向行走遇到的第一个节点）之间的数据，其它不受影响**。增加一个节点也同理。

燃鹅，一致性哈希算法在节点太少时，容易因为节点分布不均匀而造成**缓存热点**的问题。为了解决这种热点问题，**一致性 hash 算法引入了虚拟节点机制，即对每一个节点计算多个 hash，每个计算结果位置都放置一个虚拟节点**。这样就实现了数据的均匀分布，负载均衡。

![](http://cache410.oss-cn-beijing.aliyuncs.com/consistent-hashing-algorithm.png)



### 17.2.2 redis使用的hash slot

虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有的数据映射到一个固定范围内的整数集合，整数定义为槽（slot）。

redis cluster有固定的16384个hash slot，对每个key计算CRC16值，然后对16384取模，可以获取key对应的hash slot
redis cluster中每个master都会持有部分slot，比如有3个master，那么可能每个master持有5000多个hash slot
hash slot让node的增加和移除很简单，增加一个master，就将其他master的hash slot移动部分过去，减少一个master，就将它的hash slot移动到其他master上去
移动hash slot的成本是非常低的
客户端的api，可以对指定的数据，让他们走同一个hash slot，通过hash tag来实现出处。



## 17.3 节点间的通信协议

### 17.3.1 基本通信原理

集群元数据的维护有两种方式：

- 集中式协议
- Gossip 协议

redis cluster 节点间采用 gossip 协议进行通信。

### 17.3.2 集中式协议

集中式是将集群元数据（节点信息、故障等等）几种存储在某个节点上。集中式元数据集中存储的一个典型代表，就是大数据领域的 storm。它是分布式的大数据实时计算引擎，是集中式的元数据存储的结构，底层基于 zookeeper（分布式协调的中间件）对所有元数据进行存储维护。

![](http://cache410.oss-cn-beijing.aliyuncs.com/zookeeper-centralized-storage.png)

- 集中式的好处: 元数据的读取和更新，时效性非常好，一旦元数据出现了变更，就立即更新到集中式的存储中，其它节点读取的时候就可以感知到
- 不好在于，所有的元数据的更新压力全部集中在一个地方，可能会导致元数据的存储有压力。



### 17.3.3 gossip 协议 

gossip 协议包含多种消息，包含 ping,pong,meet,fail 等等。

- meet：某个节点发送 meet 给新加入的节点，让新节点加入集群中，然后新节点就会开始与其它节点进行通信。

  ```
  aredis-trib.rb add-node
  其实内部就是发送了一个 gossip meet 消息给新加入的节点，通知那个节点去加入我们的集群
  ```

- ping：每个节点都会频繁给其它节点发送 ping，其中包含自己的状态还有自己维护的集群元数据，互相通过 ping 交换元数据。

- pong：返回 ping 和 meeet，包含自己的状态和其它信息，也用于信息广播和更新。

- fail：某个节点判断另一个节点 fail 之后，就发送 fail 给其它节点，通知其它节点说，某个节点宕机啦。



gossip协议优缺点:

- gossip 好处在于，元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续打到所有节点上去更新，降低了压力
- 不好在于，元数据的更新有延时，可能导致集群中的一些操作会有一些滞后。

### 17.3.4 Redis中的gossip协议

redis 维护集群元数据采用另一个方式， gossip 协议，所有节点都持有一份元数据，不同的节点如果出现了元数据的变更，就不断将元数据发送给其它的节点，让其它节点也进行元数据的变更。

![](http://cache410.oss-cn-beijing.aliyuncs.com/redis-gossip.png)





- 10000 端口：每个节点都有一个专门用于节点间通信的端口，就是自己提供服务的端口号+10000，比如 7001，那么用于节点间通信的就是 17001 端口。每个节点每隔一段时间都会往另外几个节点发送 ping 消息，同时其它几个节点接收到 ping 之后返回 pong。
- 交换的信息：信息包括故障信息，节点的增加和删除，hash slot 信息等等。



## 17.4Redis cluster功能限制

Redis集群相对单机在功能上有一定限制:

- key批量操作支持有限。如：MSET,MGET，目前只支持具有相同slot值的key执行批量操作。
- key事务操作支持有限。支持多key在同一节点上的事务操作，不支持分布在多个节点的事务功能。
- key作为数据分区的最小粒度，因此不能将一个大的键值对象映射到不同的节点。如：hash、list。
- 不支持多数据库空间。单机下Redis支持16个数据库，集群模式下只能使用一个数据库空间，即db0。
- 复制结构只支持一层，不支持嵌套树状复制结构。
