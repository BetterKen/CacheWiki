# 19 Redis雪崩击穿穿透

## 19.1 雪崩

### 19.1.1 定义

缓存同一时间大面积的失效，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。

### 19.1.2 解决方式

- 事前:尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略

  - **缓存预热**:数据加热的含义就是在正式部署之前，把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。可以使用阿里开源的**canal**
  - **设置热点数据永远不过期**，有更新操作就更新缓存就好了
  - 往Redis存数据的时候，把每个Key的**失效时间都加个随机值**就好了，这样可以保证数据不会在同一时间大面积失效

  ```java
  setRedis（Key，value，time + Math.random() * 10000）；
  ```

- 事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉

- 事后：利用 redis 持久化机制保存的数据尽快恢复缓存

## 19.2 击穿

### 19.2.1 定义

缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况，当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。

### 19.2.2 解决方式

不同场景下的解决方式可如下：

- 若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。
- 若缓存的数据更新不频繁，且缓存刷新的整个流程耗时较少的情况下，则可以采用基于 redis、zookeeper 等分布式中间件的分布式互斥锁，或者本地互斥锁以保证仅少量的请求能请求数据库并重新构建缓存，其余线程则在锁释放后能访问到新缓存。
- 若缓存的数据更新频繁或者缓存刷新的流程耗时较长的情况下，可以利用定时线程在缓存过期前主动的重新构建缓存或者延后缓存的过期时间，以保证所有的请求能一直访问到对应的缓存。



## 19.3 穿透

### 19.3.1 定义

对于系统A，假设一秒 5000 个请求，结果其中 4000 个请求是黑客发出的恶意攻击。

黑客发出的那 4000 个攻击，缓存中查不到，每次你去数据库里查，也查不到。

举个栗子。数据库 id 是从 1 开始的，结果黑客发过来的请求 id 全部都是负数。这样的话，缓存中不会有，请求每次都“视缓存于无物”，直接查询数据库。这种恶意攻击场景的缓存穿透就会直接把数据库给打死。



### 19.3.2 解决方式

- **初级**:每次系统 A 从数据库中只要没查到，就**写一个空值到缓存**里去，比如 `set -999 UNKNOWN`。然后设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据。
- **进阶**: **在接口层增加校验**，比如用户鉴权校验，参数做校验，不合法的参数直接代码Return，比如：id 做基础校验，id <=0的直接拦截等。
- **高级**: 使用**布隆过滤器（Bloom Filter）**这个也能很好的防止缓存穿透的发生，他的原理也很简单就是利用高效的数据结构和算法快速**判断出你这个Key是否在数据库中存在，不存在你return就好了，存在你就去查了DB刷新KV再return**。