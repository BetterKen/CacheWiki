# 20 Redis缓存数据库读写一致性

## 20.1 Cache Aside Pattern 

最经典的缓存+数据库读写的模式:Cache Aside Pattern 　旁路缓存

有几个原则:

- 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
- 更新的时候，先**删除缓存**，然后再更新数据库。

### 20.1.1 删除缓存

更新时是删除缓存，而不是更新缓存

- 缓存有的时候不但是从数据库里取出的一个简单值,可能会经过复杂计算

- 更新的数据不一定会被频繁访问到,如果去更新缓存可能会**造成大量的冷数据**
- 懒加载思想:**用到缓存才去算缓存**



## 20.2 双写不一致问题

### 20.2.1 更新顺序颠倒情形 

问题描述: **先修改数据库,再删除缓存**,当删除缓存失败了,会导致数据库中是新数据,缓存中是旧数据

解决思路: **先删除缓存,再更新数据库**,如果删除缓存成功了,修改数据库失败了,那么数据库中是旧数据,缓存中是空的,那么数据不会不一致,因为读的时候缓存没有,则读数据库中的旧数据,然后更新到缓存中



### 20.2.2 更新数据库并发读情形 

问题描述:数据发生了变更,先删除了缓存,然后要去修改数据库,**此时还没有修改数据库**,一个请求过来去读缓存,没有读到,去查数据库,**查到了修改前的旧数据,放到缓存中**,数据变更的程序完成了数据库的修改,此时数据库和缓存的数据不一致了

解决思路:　更新数据的时候，根据数据的唯一标识，hash之后，**发送到一个队列中,队列可是redis的队列,Java的内存队列**等,读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个队列中。

一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。

这里有一个**优化点**，一个队列中，**其实多个更新缓存请求串在一起是没意义的**，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。

待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。

如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值

